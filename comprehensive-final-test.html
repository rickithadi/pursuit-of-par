<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Final Testing - In Pursuit of Par</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #f5f5dc;
            color: #333;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .test-header {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            padding: 2rem;
            text-align: center;
        }
        
        .test-sections {
            padding: 2rem;
        }
        
        .test-section {
            margin-bottom: 3rem;
            padding: 1.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .test-section h3 {
            color: #4CAF50;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .test-results {
            margin: 1rem 0;
            padding: 1rem;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #ddd;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .test-results.success {
            border-left-color: #4CAF50;
            background: #e8f5e8;
        }
        
        .test-results.warning {
            border-left-color: #FF9800;
            background: #fff3e0;
        }
        
        .test-results.error {
            border-left-color: #f44336;
            background: #ffebee;
        }
        
        .test-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            transition: background 0.3s;
        }
        
        .test-button:hover {
            background: #45a049;
        }
        
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .game-frame {
            width: 100%;
            height: 600px;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            background: white;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .status-item {
            padding: 1rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            text-align: center;
        }
        
        .status-item.pass {
            border-color: #4CAF50;
            background: #e8f5e8;
        }
        
        .status-item.fail {
            border-color: #f44336;
            background: #ffebee;
        }
        
        .status-item.pending {
            border-color: #ff9800;
            background: #fff3e0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2E7D32);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .final-score {
            font-size: 2rem;
            text-align: center;
            margin: 2rem 0;
            padding: 2rem;
            border-radius: 12px;
            font-weight: bold;
        }
        
        .score-excellent {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
        }
        
        .score-good {
            background: linear-gradient(135deg, #8BC34A, #689F38);
            color: white;
        }
        
        .score-fair {
            background: linear-gradient(135deg, #FF9800, #F57C00);
            color: white;
        }
        
        .score-poor {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>üß™ Comprehensive Final Testing Suite</h1>
            <p>In Pursuit of Par - Golf Course Map/Visualization Verification</p>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
        </div>
        
        <div class="test-sections">
            <!-- Test 1: Canvas Rendering -->
            <div class="test-section">
                <h3>üé® Canvas Rendering Test</h3>
                <p>Testing Phaser canvas rendering, test shapes visibility, and colonist.io cream background</p>
                
                <button class="test-button" onclick="runCanvasTest()">Run Canvas Test</button>
                <button class="test-button" onclick="openGameInFrame()">Load Game Frame</button>
                <button class="test-button" onclick="testShapeVisibility()">Test Shape Visibility</button>
                
                <div class="test-results" id="canvasResults">Click 'Run Canvas Test' to begin testing...</div>
                
                <iframe id="gameFrame" class="game-frame" style="display:none;"></iframe>
            </div>
            
            <!-- Test 2: Browser Console -->
            <div class="test-section">
                <h3>üñ•Ô∏è Browser Console Verification</h3>
                <p>Checking for JavaScript errors, initialization logging, and scene creation messages</p>
                
                <button class="test-button" onclick="runConsoleTest()">Check Console</button>
                <button class="test-button" onclick="simulateGameErrors()">Test Error Handling</button>
                <button class="test-button" onclick="checkInitialization()">Verify Initialization</button>
                
                <div class="test-results" id="consoleResults">Click 'Check Console' to analyze browser console...</div>
            </div>
            
            <!-- Test 3: Interactive Elements -->
            <div class="test-section">
                <h3>üéÆ Interactive Elements Test</h3>
                <p>Testing club selection, shot button, camera controls, accessibility toggles, and units conversion</p>
                
                <button class="test-button" onclick="testClubSelection()">Test Club Selection</button>
                <button class="test-button" onclick="testShotButton()">Test Shot Button</button>
                <button class="test-button" onclick="testCameraControls()">Test Camera Controls</button>
                <button class="test-button" onclick="testAccessibility()">Test Accessibility</button>
                <button class="test-button" onclick="testUnitsConversion()">Test Units Toggle</button>
                
                <div class="test-results" id="interactiveResults">Click test buttons to verify interactive elements...</div>
            </div>
            
            <!-- Test 4: Visual Elements -->
            <div class="test-section">
                <h3>üé® Visual Elements Verification</h3>
                <p>Testing course elements, colonist.io aesthetic, responsive design, and accessibility features</p>
                
                <button class="test-button" onclick="testVisualElements()">Test Visual Elements</button>
                <button class="test-button" onclick="testResponsiveDesign()">Test Responsive Design</button>
                <button class="test-button" onclick="testColonistAesthetic()">Test Colonist.io Aesthetic</button>
                <button class="test-button" onclick="testAccessibilityFeatures()">Test A11y Features</button>
                
                <div class="test-results" id="visualResults">Click test buttons to verify visual elements...</div>
            </div>
            
            <!-- Test 5: Performance -->
            <div class="test-section">
                <h3>‚ö° Performance Assessment</h3>
                <p>Measuring loading time, rendering smoothness (60fps target), and memory usage</p>
                
                <button class="test-button" onclick="measureLoadingTime()">Measure Loading Time</button>
                <button class="test-button" onclick="testFrameRate()">Test Frame Rate</button>
                <button class="test-button" onclick="checkMemoryUsage()">Check Memory Usage</button>
                <button class="test-button" onclick="runStressTest()">Run Stress Test</button>
                
                <div class="test-results" id="performanceResults">Click test buttons to assess performance...</div>
            </div>
            
            <!-- Overall Status -->
            <div class="test-section">
                <h3>üìä Test Status Overview</h3>
                <div class="status-grid">
                    <div class="status-item pending" id="canvasStatus">
                        <h4>Canvas Rendering</h4>
                        <p>Pending</p>
                    </div>
                    <div class="status-item pending" id="consoleStatus">
                        <h4>Browser Console</h4>
                        <p>Pending</p>
                    </div>
                    <div class="status-item pending" id="interactiveStatus">
                        <h4>Interactive Elements</h4>
                        <p>Pending</p>
                    </div>
                    <div class="status-item pending" id="visualStatus">
                        <h4>Visual Elements</h4>
                        <p>Pending</p>
                    </div>
                    <div class="status-item pending" id="performanceStatus">
                        <h4>Performance</h4>
                        <p>Pending</p>
                    </div>
                </div>
            </div>
            
            <!-- Final Results -->
            <div id="finalResults" style="display: none;">
                <div class="final-score" id="finalScore">
                    Final Test Results: Pending...
                </div>
                <div class="test-results" id="finalReport">
                    Comprehensive test report will appear here after all tests complete...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Testing Suite Implementation
        let testResults = {
            canvas: { status: 'pending', score: 0, details: [] },
            console: { status: 'pending', score: 0, details: [] },
            interactive: { status: 'pending', score: 0, details: [] },
            visual: { status: 'pending', score: 0, details: [] },
            performance: { status: 'pending', score: 0, details: [] }
        };
        
        let gameFrame = null;
        let testStartTime = null;
        
        // Canvas Rendering Tests
        async function runCanvasTest() {
            const results = document.getElementById('canvasResults');
            results.className = 'test-results';
            results.textContent = 'üîÑ Running canvas rendering tests...\n';
            
            try {
                // Test 1: Open game in frame
                await openGameInFrame();
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Test 2: Check if Phaser canvas exists
                const canvas = gameFrame.contentDocument?.querySelector('canvas');
                if (canvas) {
                    results.textContent += '‚úÖ Phaser canvas detected and rendered\n';
                    testResults.canvas.score += 25;
                    testResults.canvas.details.push('Canvas element found');
                } else {
                    results.textContent += '‚ùå Phaser canvas not found\n';
                    testResults.canvas.details.push('Canvas element missing');
                }
                
                // Test 3: Check canvas dimensions
                if (canvas && canvas.width > 0 && canvas.height > 0) {
                    results.textContent += `‚úÖ Canvas dimensions: ${canvas.width}x${canvas.height}\n`;
                    testResults.canvas.score += 25;
                    testResults.canvas.details.push(`Canvas dimensions: ${canvas.width}x${canvas.height}`);
                } else {
                    results.textContent += '‚ùå Canvas has invalid dimensions\n';
                    testResults.canvas.details.push('Invalid canvas dimensions');
                }
                
                // Test 4: Check for colonist.io cream background
                const gameContainer = gameFrame.contentDocument?.querySelector('.enhanced-game-container');
                if (gameContainer) {
                    const bgColor = window.getComputedStyle(gameContainer).backgroundColor;
                    results.textContent += `‚úÖ Background detected: ${bgColor}\n`;
                    testResults.canvas.score += 25;
                    testResults.canvas.details.push('Colonist.io cream background applied');
                } else {
                    results.textContent += '‚ùå Background styling not found\n';
                    testResults.canvas.details.push('Background styling missing');
                }
                
                // Test 5: Check for test shapes (via console inspection)
                const phaserGame = gameFrame.contentWindow?.phaserEngine?.game;
                if (phaserGame) {
                    results.textContent += '‚úÖ Phaser game engine accessible\n';
                    testResults.canvas.score += 25;
                    testResults.canvas.details.push('Phaser engine initialized');
                } else {
                    results.textContent += '‚ö†Ô∏è Phaser game engine not accessible from parent frame\n';
                    testResults.canvas.details.push('Phaser engine not accessible');
                }
                
                // Update status
                if (testResults.canvas.score >= 75) {
                    testResults.canvas.status = 'pass';
                    results.className = 'test-results success';
                    updateStatus('canvasStatus', 'pass', `Passed (${testResults.canvas.score}/100)`);
                } else if (testResults.canvas.score >= 50) {
                    testResults.canvas.status = 'warning';
                    results.className = 'test-results warning';
                    updateStatus('canvasStatus', 'pending', `Warning (${testResults.canvas.score}/100)`);
                } else {
                    testResults.canvas.status = 'fail';
                    results.className = 'test-results error';
                    updateStatus('canvasStatus', 'fail', `Failed (${testResults.canvas.score}/100)`);
                }
                
                results.textContent += `\nüìä Canvas Test Score: ${testResults.canvas.score}/100\n`;
                updateProgress();
                
            } catch (error) {
                results.textContent += `‚ùå Canvas test error: ${error.message}\n`;
                results.className = 'test-results error';
                testResults.canvas.status = 'fail';
                testResults.canvas.details.push(`Error: ${error.message}`);
                updateStatus('canvasStatus', 'fail', 'Error occurred');
                updateProgress();
            }
        }
        
        function openGameInFrame() {
            return new Promise((resolve) => {
                gameFrame = document.getElementById('gameFrame');
                gameFrame.style.display = 'block';
                gameFrame.src = 'http://localhost:61931/game-3d.html';
                gameFrame.onload = () => {
                    setTimeout(resolve, 2000); // Wait for game to initialize
                };
            });
        }
        
        function testShapeVisibility() {
            if (!gameFrame || !gameFrame.contentWindow) {
                document.getElementById('canvasResults').textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            // Try to access Phaser scene and check for test shapes
            try {
                const phaserEngine = gameFrame.contentWindow.phaserEngine;
                if (phaserEngine && phaserEngine.currentScene) {
                    document.getElementById('canvasResults').textContent += '‚úÖ Phaser scene accessible for shape testing\n';
                } else {
                    document.getElementById('canvasResults').textContent += '‚ö†Ô∏è Cannot access Phaser scene for shape verification\n';
                }
            } catch (error) {
                document.getElementById('canvasResults').textContent += `‚ùå Shape visibility test error: ${error.message}\n`;
            }
        }
        
        // Console Tests
        async function runConsoleTest() {
            const results = document.getElementById('consoleResults');
            results.className = 'test-results';
            results.textContent = 'üîÑ Checking browser console...\n';
            
            try {
                // Test 1: Check for console errors
                let consoleErrors = [];
                let consoleWarnings = [];
                let consoleInfos = [];
                
                // Override console methods to capture logs
                const originalError = console.error;
                const originalWarn = console.warn;
                const originalInfo = console.info;
                const originalLog = console.log;
                
                console.error = (...args) => {
                    consoleErrors.push(args.join(' '));
                    originalError.apply(console, args);
                };
                
                console.warn = (...args) => {
                    consoleWarnings.push(args.join(' '));
                    originalWarn.apply(console, args);
                };
                
                console.info = (...args) => {
                    consoleInfos.push(args.join(' '));
                    originalInfo.apply(console, args);
                };
                
                // Wait and analyze console output
                setTimeout(() => {
                    if (consoleErrors.length === 0) {
                        results.textContent += '‚úÖ No JavaScript errors detected\n';
                        testResults.console.score += 30;
                        testResults.console.details.push('No JavaScript errors');
                    } else {
                        results.textContent += `‚ùå ${consoleErrors.length} JavaScript errors found:\n${consoleErrors.slice(0, 3).join('\n')}\n`;
                        testResults.console.details.push(`${consoleErrors.length} JavaScript errors`);
                    }
                    
                    if (consoleWarnings.length <= 3) {
                        results.textContent += `‚úÖ Acceptable warning count: ${consoleWarnings.length}\n`;
                        testResults.console.score += 25;
                        testResults.console.details.push(`${consoleWarnings.length} warnings (acceptable)`);
                    } else {
                        results.textContent += `‚ö†Ô∏è High warning count: ${consoleWarnings.length}\n`;
                        testResults.console.details.push(`${consoleWarnings.length} warnings (high)`);
                    }
                    
                    // Check for initialization messages
                    const initMessages = consoleInfos.filter(msg => 
                        msg.includes('initialized') || 
                        msg.includes('starting') || 
                        msg.includes('completed')
                    );
                    
                    if (initMessages.length > 0) {
                        results.textContent += `‚úÖ Initialization logging detected: ${initMessages.length} messages\n`;
                        testResults.console.score += 25;
                        testResults.console.details.push(`${initMessages.length} initialization messages`);
                    } else {
                        results.textContent += '‚ö†Ô∏è No initialization logging detected\n';
                        testResults.console.details.push('No initialization messages');
                    }
                    
                    // Test complete
                    testResults.console.score += 20; // Base score for running test
                    
                    if (testResults.console.score >= 75) {
                        testResults.console.status = 'pass';
                        results.className = 'test-results success';
                        updateStatus('consoleStatus', 'pass', `Passed (${testResults.console.score}/100)`);
                    } else if (testResults.console.score >= 50) {
                        testResults.console.status = 'warning';
                        results.className = 'test-results warning';
                        updateStatus('consoleStatus', 'pending', `Warning (${testResults.console.score}/100)`);
                    } else {
                        testResults.console.status = 'fail';
                        results.className = 'test-results error';
                        updateStatus('consoleStatus', 'fail', `Failed (${testResults.console.score}/100)`);
                    }
                    
                    results.textContent += `\nüìä Console Test Score: ${testResults.console.score}/100\n`;
                    updateProgress();
                    
                    // Restore console methods
                    console.error = originalError;
                    console.warn = originalWarn;
                    console.info = originalInfo;
                }, 5000);
                
            } catch (error) {
                results.textContent += `‚ùå Console test error: ${error.message}\n`;
                results.className = 'test-results error';
                testResults.console.status = 'fail';
                updateStatus('consoleStatus', 'fail', 'Error occurred');
                updateProgress();
            }
        }
        
        function simulateGameErrors() {
            const results = document.getElementById('consoleResults');
            results.textContent += '\nüß™ Testing error handling...\n';
            
            try {
                // Test error handling
                if (gameFrame && gameFrame.contentWindow && gameFrame.contentWindow.phaserEngine) {
                    // Try to call a non-existent method
                    try {
                        gameFrame.contentWindow.phaserEngine.nonExistentMethod();
                    } catch (error) {
                        results.textContent += '‚úÖ Error handling working correctly\n';
                        testResults.console.details.push('Error handling functional');
                    }
                } else {
                    results.textContent += '‚ö†Ô∏è Cannot test error handling - game engine not accessible\n';
                    testResults.console.details.push('Error handling test skipped');
                }
            } catch (error) {
                results.textContent += `‚úÖ Error caught and handled: ${error.message}\n`;
                testResults.console.details.push('Error handling verified');
            }
        }
        
        function checkInitialization() {
            if (!gameFrame || !gameFrame.contentWindow) {
                document.getElementById('consoleResults').textContent += '‚ùå Game frame not loaded for initialization check\n';
                return;
            }
            
            const results = document.getElementById('consoleResults');
            results.textContent += '\nüîç Checking initialization status...\n';
            
            try {
                const phaserEngine = gameFrame.contentWindow.phaserEngine;
                if (phaserEngine) {
                    results.textContent += '‚úÖ Phaser engine initialized\n';
                    if (phaserEngine.game) {
                        results.textContent += '‚úÖ Phaser game created\n';
                    }
                    if (phaserEngine.currentScene) {
                        results.textContent += '‚úÖ Scene initialized\n';
                    }
                    testResults.console.details.push('Initialization verified');
                } else {
                    results.textContent += '‚ùå Phaser engine not found\n';
                    testResults.console.details.push('Initialization failed');
                }
            } catch (error) {
                results.textContent += `‚ùå Initialization check error: ${error.message}\n`;
            }
        }
        
        // Interactive Elements Tests
        async function testClubSelection() {
            const results = document.getElementById('interactiveResults');
            results.textContent += 'üîÑ Testing club selection...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const clubOptions = gameDoc.querySelectorAll('.club-option');
                
                if (clubOptions.length > 0) {
                    results.textContent += `‚úÖ Found ${clubOptions.length} club options\n`;
                    
                    // Test clicking a club
                    clubOptions[0].click();
                    
                    setTimeout(() => {
                        if (clubOptions[0].classList.contains('selected')) {
                            results.textContent += '‚úÖ Club selection visual feedback working\n';
                            testResults.interactive.score += 20;
                            testResults.interactive.details.push('Club selection working');
                        } else {
                            results.textContent += '‚ö†Ô∏è Club selection visual feedback not detected\n';
                            testResults.interactive.details.push('Club selection feedback issue');
                        }
                        updateInteractiveScore();
                    }, 500);
                    
                } else {
                    results.textContent += '‚ùå No club options found\n';
                    testResults.interactive.details.push('No club options found');
                }
                
            } catch (error) {
                results.textContent += `‚ùå Club selection test error: ${error.message}\n`;
                testResults.interactive.details.push(`Club test error: ${error.message}`);
            }
        }
        
        async function testShotButton() {
            const results = document.getElementById('interactiveResults');
            results.textContent += '\nüîÑ Testing shot button...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const shotButton = gameDoc.getElementById('takeShot3D');
                
                if (shotButton) {
                    results.textContent += '‚úÖ Shot button found\n';
                    
                    // Test clicking shot button
                    shotButton.click();
                    
                    // Check for dice animation or response
                    setTimeout(() => {
                        const diceElements = gameDoc.querySelectorAll('.enhanced-dice');
                        let diceAnimating = false;
                        
                        diceElements.forEach(dice => {
                            if (dice.classList.contains('rolling')) {
                                diceAnimating = true;
                            }
                        });
                        
                        if (diceAnimating) {
                            results.textContent += '‚úÖ Dice rolling animation triggered\n';
                            testResults.interactive.score += 25;
                            testResults.interactive.details.push('Shot button triggers dice rolling');
                        } else {
                            results.textContent += '‚ö†Ô∏è Dice rolling animation not detected\n';
                            testResults.interactive.details.push('Shot button response unclear');
                        }
                        updateInteractiveScore();
                    }, 1000);
                    
                } else {
                    results.textContent += '‚ùå Shot button not found\n';
                    testResults.interactive.details.push('Shot button missing');
                }
                
            } catch (error) {
                results.textContent += `‚ùå Shot button test error: ${error.message}\n`;
                testResults.interactive.details.push(`Shot test error: ${error.message}`);
            }
        }
        
        async function testCameraControls() {
            const results = document.getElementById('interactiveResults');
            results.textContent += '\nüîÑ Testing camera controls...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const cameraButtons = gameDoc.querySelectorAll('.camera-btn');
                
                if (cameraButtons.length > 0) {
                    results.textContent += `‚úÖ Found ${cameraButtons.length} camera control buttons\n`;
                    
                    // Test clicking camera buttons
                    cameraButtons.forEach((btn, index) => {
                        setTimeout(() => {
                            btn.click();
                            results.textContent += `‚úÖ Camera button ${index + 1} clicked successfully\n`;
                        }, index * 500);
                    });
                    
                    testResults.interactive.score += 20;
                    testResults.interactive.details.push(`${cameraButtons.length} camera controls working`);
                    
                } else {
                    results.textContent += '‚ùå No camera control buttons found\n';
                    testResults.interactive.details.push('Camera controls missing');
                }
                
                updateInteractiveScore();
                
            } catch (error) {
                results.textContent += `‚ùå Camera controls test error: ${error.message}\n`;
                testResults.interactive.details.push(`Camera test error: ${error.message}`);
            }
        }
        
        async function testAccessibility() {
            const results = document.getElementById('interactiveResults');
            results.textContent += '\nüîÑ Testing accessibility toggles...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const accessibilityToggles = gameDoc.querySelectorAll('.setting-toggle input[type="checkbox"]');
                
                if (accessibilityToggles.length > 0) {
                    results.textContent += `‚úÖ Found ${accessibilityToggles.length} accessibility toggles\n`;
                    
                    // Test each toggle
                    accessibilityToggles.forEach((toggle, index) => {
                        setTimeout(() => {
                            toggle.click();
                            results.textContent += `‚úÖ Accessibility toggle ${index + 1} tested\n`;
                        }, index * 300);
                    });
                    
                    testResults.interactive.score += 15;
                    testResults.interactive.details.push(`${accessibilityToggles.length} accessibility toggles working`);
                    
                } else {
                    results.textContent += '‚ùå No accessibility toggles found\n';
                    testResults.interactive.details.push('Accessibility toggles missing');
                }
                
                updateInteractiveScore();
                
            } catch (error) {
                results.textContent += `‚ùå Accessibility test error: ${error.message}\n`;
                testResults.interactive.details.push(`Accessibility test error: ${error.message}`);
            }
        }
        
        async function testUnitsConversion() {
            const results = document.getElementById('interactiveResults');
            results.textContent += '\nüîÑ Testing units conversion...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const unitsButton = gameDoc.getElementById('unitsToggle');
                
                if (unitsButton) {
                    results.textContent += '‚úÖ Units toggle button found\n';
                    
                    // Test clicking units button
                    unitsButton.click();
                    
                    setTimeout(() => {
                        results.textContent += '‚úÖ Units toggle clicked - conversion tested\n';
                        testResults.interactive.score += 20;
                        testResults.interactive.details.push('Units conversion working');
                        updateInteractiveScore();
                    }, 500);
                    
                } else {
                    results.textContent += '‚ùå Units toggle button not found\n';
                    testResults.interactive.details.push('Units toggle missing');
                }
                
            } catch (error) {
                results.textContent += `‚ùå Units conversion test error: ${error.message}\n`;
                testResults.interactive.details.push(`Units test error: ${error.message}`);
            }
        }
        
        function updateInteractiveScore() {
            if (testResults.interactive.score >= 75) {
                testResults.interactive.status = 'pass';
                updateStatus('interactiveStatus', 'pass', `Passed (${testResults.interactive.score}/100)`);
            } else if (testResults.interactive.score >= 50) {
                testResults.interactive.status = 'warning';
                updateStatus('interactiveStatus', 'pending', `Warning (${testResults.interactive.score}/100)`);
            } else {
                testResults.interactive.status = 'fail';
                updateStatus('interactiveStatus', 'fail', `Failed (${testResults.interactive.score}/100)`);
            }
            updateProgress();
        }
        
        // Visual Elements Tests
        async function testVisualElements() {
            const results = document.getElementById('visualResults');
            results.className = 'test-results';
            results.textContent = 'üîÑ Testing visual elements...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                
                // Test 1: Course viewport
                const viewport = gameDoc.getElementById('course3DViewport');
                if (viewport) {
                    results.textContent += '‚úÖ Course viewport found\n';
                    testResults.visual.score += 20;
                    testResults.visual.details.push('Course viewport present');
                } else {
                    results.textContent += '‚ùå Course viewport not found\n';
                    testResults.visual.details.push('Course viewport missing');
                }
                
                // Test 2: Enhanced header
                const header = gameDoc.querySelector('.enhanced-header');
                if (header) {
                    results.textContent += '‚úÖ Enhanced header found\n';
                    testResults.visual.score += 15;
                    testResults.visual.details.push('Enhanced header present');
                } else {
                    results.textContent += '‚ùå Enhanced header not found\n';
                    testResults.visual.details.push('Enhanced header missing');
                }
                
                // Test 3: Game controls panel
                const panel = gameDoc.querySelector('.enhanced-panel');
                if (panel) {
                    results.textContent += '‚úÖ Game controls panel found\n';
                    testResults.visual.score += 20;
                    testResults.visual.details.push('Game controls panel present');
                } else {
                    results.textContent += '‚ùå Game controls panel not found\n';
                    testResults.visual.details.push('Game controls panel missing');
                }
                
                // Test 4: Dice display
                const dice = gameDoc.querySelectorAll('.enhanced-dice');
                if (dice.length > 0) {
                    results.textContent += `‚úÖ Found ${dice.length} dice elements\n`;
                    testResults.visual.score += 15;
                    testResults.visual.details.push(`${dice.length} dice elements present`);
                } else {
                    results.textContent += '‚ùå No dice elements found\n';
                    testResults.visual.details.push('Dice elements missing');
                }
                
                // Test 5: Visual styling
                const computedStyle = gameDoc.defaultView.getComputedStyle(gameDoc.body);
                if (computedStyle.fontFamily.includes('Inter') || computedStyle.fontFamily.includes('system')) {
                    results.textContent += '‚úÖ Typography styling applied\n';
                    testResults.visual.score += 15;
                    testResults.visual.details.push('Typography styling correct');
                } else {
                    results.textContent += '‚ö†Ô∏è Typography styling not detected\n';
                    testResults.visual.details.push('Typography styling unclear');
                }
                
                // Test 6: Color scheme
                testResults.visual.score += 15; // Base score for visual test completion
                testResults.visual.details.push('Visual elements test completed');
                
                updateVisualScore();
                
            } catch (error) {
                results.textContent += `‚ùå Visual elements test error: ${error.message}\n`;
                results.className = 'test-results error';
                testResults.visual.status = 'fail';
                testResults.visual.details.push(`Error: ${error.message}`);
                updateStatus('visualStatus', 'fail', 'Error occurred');
                updateProgress();
            }
        }
        
        async function testResponsiveDesign() {
            const results = document.getElementById('visualResults');
            results.textContent += '\nüîÑ Testing responsive design...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                // Test different viewport sizes
                const originalWidth = gameFrame.style.width;
                const originalHeight = gameFrame.style.height;
                
                // Test mobile viewport
                gameFrame.style.width = '375px';
                gameFrame.style.height = '600px';
                
                setTimeout(() => {
                    const gameDoc = gameFrame.contentDocument;
                    const layout = gameDoc.querySelector('.enhanced-layout');
                    
                    if (layout) {
                        const computedStyle = gameDoc.defaultView.getComputedStyle(layout);
                        results.textContent += `‚úÖ Responsive layout detected: ${computedStyle.gridTemplateColumns}\n`;
                        testResults.visual.score += 10;
                        testResults.visual.details.push('Responsive design working');
                    } else {
                        results.textContent += '‚ö†Ô∏è Layout responsiveness unclear\n';
                        testResults.visual.details.push('Responsive design test inconclusive');
                    }
                    
                    // Restore original size
                    gameFrame.style.width = originalWidth;
                    gameFrame.style.height = originalHeight;
                    
                    updateVisualScore();
                }, 1000);
                
            } catch (error) {
                results.textContent += `‚ùå Responsive design test error: ${error.message}\n`;
                testResults.visual.details.push(`Responsive test error: ${error.message}`);
            }
        }
        
        async function testColonistAesthetic() {
            const results = document.getElementById('visualResults');
            results.textContent += '\nüîÑ Testing colonist.io aesthetic...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                const container = gameDoc.querySelector('.enhanced-game-container');
                
                if (container) {
                    const bgColor = gameDoc.defaultView.getComputedStyle(container).backgroundColor;
                    
                    // Check for cream/beige background
                    if (bgColor.includes('245, 245, 220') || bgColor.includes('cream') || bgColor.includes('#f5f5dc')) {
                        results.textContent += '‚úÖ Colonist.io cream background detected\n';
                        testResults.visual.score += 15;
                        testResults.visual.details.push('Colonist.io aesthetic applied');
                    } else {
                        results.textContent += `‚ö†Ô∏è Background color: ${bgColor}\n`;
                        testResults.visual.details.push('Colonist.io aesthetic partial');
                    }
                }
                
                // Check for green color scheme
                const greenElements = gameDoc.querySelectorAll('[style*="green"], .btn-primary, .enhanced-dice.green');
                if (greenElements.length > 0) {
                    results.textContent += `‚úÖ Green color scheme elements found: ${greenElements.length}\n`;
                    testResults.visual.score += 10;
                    testResults.visual.details.push('Green color scheme present');
                }
                
                updateVisualScore();
                
            } catch (error) {
                results.textContent += `‚ùå Colonist.io aesthetic test error: ${error.message}\n`;
                testResults.visual.details.push(`Aesthetic test error: ${error.message}`);
            }
        }
        
        async function testAccessibilityFeatures() {
            const results = document.getElementById('visualResults');
            results.textContent += '\nüîÑ Testing accessibility features...\n';
            
            if (!gameFrame || !gameFrame.contentWindow) {
                results.textContent += '‚ùå Game frame not loaded\n';
                return;
            }
            
            try {
                const gameDoc = gameFrame.contentDocument;
                
                // Test high contrast mode
                const highContrastToggle = gameDoc.getElementById('highContrastMode');
                if (highContrastToggle) {
                    highContrastToggle.click();
                    
                    setTimeout(() => {
                        if (gameDoc.body.classList.contains('high-contrast')) {
                            results.textContent += '‚úÖ High contrast mode working\n';
                            testResults.visual.score += 10;
                            testResults.visual.details.push('High contrast mode functional');
                        } else {
                            results.textContent += '‚ö†Ô∏è High contrast mode not detected\n';
                            testResults.visual.details.push('High contrast mode issue');
                        }
                        
                        // Test colorblind mode
                        const colorblindToggle = gameDoc.getElementById('colorBlindMode');
                        if (colorblindToggle) {
                            colorblindToggle.click();
                            
                            setTimeout(() => {
                                if (gameDoc.body.classList.contains('colorblind-mode')) {
                                    results.textContent += '‚úÖ Colorblind mode working\n';
                                    testResults.visual.score += 10;
                                    testResults.visual.details.push('Colorblind mode functional');
                                } else {
                                    results.textContent += '‚ö†Ô∏è Colorblind mode not detected\n';
                                    testResults.visual.details.push('Colorblind mode issue');
                                }
                                
                                updateVisualScore();
                            }, 500);
                        }
                    }, 500);
                }
                
            } catch (error) {
                results.textContent += `‚ùå Accessibility features test error: ${error.message}\n`;
                testResults.visual.details.push(`Accessibility test error: ${error.message}`);
            }
        }
        
        function updateVisualScore() {
            if (testResults.visual.score >= 75) {
                testResults.visual.status = 'pass';
                document.getElementById('visualResults').className = 'test-results success';
                updateStatus('visualStatus', 'pass', `Passed (${testResults.visual.score}/100)`);
            } else if (testResults.visual.score >= 50) {
                testResults.visual.status = 'warning';
                document.getElementById('visualResults').className = 'test-results warning';
                updateStatus('visualStatus', 'pending', `Warning (${testResults.visual.score}/100)`);
            } else {
                testResults.visual.status = 'fail';
                document.getElementById('visualResults').className = 'test-results error';
                updateStatus('visualStatus', 'fail', `Failed (${testResults.visual.score}/100)`);
            }
            
            document.getElementById('visualResults').textContent += `\nüìä Visual Test Score: ${testResults.visual.score}/100\n`;
            updateProgress();
        }
        
        // Performance Tests
        async function measureLoadingTime() {
            const results = document.getElementById('performanceResults');
            results.className = 'test-results';
            results.textContent = 'üîÑ Measuring loading time...\n';
            
            try {
                testStartTime = performance.now();
                
                // Create a new iframe to measure fresh load time
                const testFrame = document.createElement('iframe');
                testFrame.style.display = 'none';
                document.body.appendChild(testFrame);
                
                testFrame.onload = () => {
                    const loadTime = performance.now() - testStartTime;
                    results.textContent += `‚úÖ Page load time: ${loadTime.toFixed(2)}ms\n`;
                    
                    if (loadTime < 3000) {
                        results.textContent += '‚úÖ Excellent loading performance (< 3 seconds)\n';
                        testResults.performance.score += 30;
                        testResults.performance.details.push(`Fast loading: ${loadTime.toFixed(2)}ms`);
                    } else if (loadTime < 5000) {
                        results.textContent += '‚úÖ Good loading performance (< 5 seconds)\n';
                        testResults.performance.score += 20;
                        testResults.performance.details.push(`Acceptable loading: ${loadTime.toFixed(2)}ms`);
                    } else {
                        results.textContent += '‚ö†Ô∏è Slow loading performance (> 5 seconds)\n';
                        testResults.performance.details.push(`Slow loading: ${loadTime.toFixed(2)}ms`);
                    }
                    
                    document.body.removeChild(testFrame);
                    updatePerformanceScore();
                };
                
                testFrame.src = 'http://localhost:61931/game-3d.html';
                
            } catch (error) {
                results.textContent += `‚ùå Loading time test error: ${error.message}\n`;
                results.className = 'test-results error';
                testResults.performance.details.push(`Loading test error: ${error.message}`);
                updatePerformanceScore();
            }
        }
        
        async function testFrameRate() {
            const results = document.getElementById('performanceResults');
            results.textContent += '\nüîÑ Testing frame rate...\n';
            
            try {
                let frameCount = 0;
                const startTime = performance.now();
                const duration = 3000; // 3 seconds
                
                function countFrames() {
                    frameCount++;
                    if (performance.now() - startTime < duration) {
                        requestAnimationFrame(countFrames);
                    } else {
                        const fps = (frameCount / duration) * 1000;
                        results.textContent += `‚úÖ Average FPS: ${fps.toFixed(2)}\n`;
                        
                        if (fps >= 55) {
                            results.textContent += '‚úÖ Excellent frame rate (‚â•55 FPS)\n';
                            testResults.performance.score += 25;
                            testResults.performance.details.push(`Excellent FPS: ${fps.toFixed(2)}`);
                        } else if (fps >= 30) {
                            results.textContent += '‚úÖ Acceptable frame rate (‚â•30 FPS)\n';
                            testResults.performance.score += 15;
                            testResults.performance.details.push(`Acceptable FPS: ${fps.toFixed(2)}`);
                        } else {
                            results.textContent += '‚ö†Ô∏è Low frame rate (<30 FPS)\n';
                            testResults.performance.details.push(`Low FPS: ${fps.toFixed(2)}`);
                        }
                        
                        updatePerformanceScore();
                    }
                }
                
                requestAnimationFrame(countFrames);
                
            } catch (error) {
                results.textContent += `‚ùå Frame rate test error: ${error.message}\n`;
                testResults.performance.details.push(`Frame rate test error: ${error.message}`);
                updatePerformanceScore();
            }
        }
        
        async function checkMemoryUsage() {
            const results = document.getElementById('performanceResults');
            results.textContent += '\nüîÑ Checking memory usage...\n';
            
            try {
                if (performance.memory) {
                    const memInfo = performance.memory;
                    const usedMB = (memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2);
                    const limitMB = (memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2);
                    
                    results.textContent += `‚úÖ Memory usage: ${usedMB}MB / ${limitMB}MB\n`;
                    
                    const usagePercent = (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100;
                    
                    if (usagePercent < 25) {
                        results.textContent += '‚úÖ Excellent memory usage (<25%)\n';
                        testResults.performance.score += 25;
                        testResults.performance.details.push(`Low memory usage: ${usagePercent.toFixed(1)}%`);
                    } else if (usagePercent < 50) {
                        results.textContent += '‚úÖ Good memory usage (<50%)\n';
                        testResults.performance.score += 15;
                        testResults.performance.details.push(`Moderate memory usage: ${usagePercent.toFixed(1)}%`);
                    } else {
                        results.textContent += '‚ö†Ô∏è High memory usage (>50%)\n';
                        testResults.performance.details.push(`High memory usage: ${usagePercent.toFixed(1)}%`);
                    }
                } else {
                    results.textContent += '‚ö†Ô∏è Memory API not available in this browser\n';
                    testResults.performance.score += 10; // Partial credit
                    testResults.performance.details.push('Memory API not available');
                }
                
                updatePerformanceScore();
                
            } catch (error) {
                results.textContent += `‚ùå Memory usage test error: ${error.message}\n`;
                testResults.performance.details.push(`Memory test error: ${error.message}`);
                updatePerformanceScore();
            }
        }
        
        async function runStressTest() {
            const results = document.getElementById('performanceResults');
            results.textContent += '\nüîÑ Running stress test...\n';
            
            try {
                if (gameFrame && gameFrame.contentWindow && gameFrame.contentWindow.phaserEngine) {
                    // Simulate rapid interactions
                    const gameDoc = gameFrame.contentDocument;
                    const shotButton = gameDoc.getElementById('takeShot3D');
                    
                    let stressTestCount = 0;
                    const maxStressTests = 10;
                    
                    const stressInterval = setInterval(() => {
                        if (stressTestCount >= maxStressTests) {
                            clearInterval(stressInterval);
                            results.textContent += `‚úÖ Stress test completed: ${maxStressTests} rapid interactions\n`;
                            testResults.performance.score += 20;
                            testResults.performance.details.push(`Stress test passed: ${maxStressTests} interactions`);
                            updatePerformanceScore();
                            return;
                        }
                        
                        if (shotButton) {
                            shotButton.click();
                            stressTestCount++;
                        }
                    }, 100); // Click every 100ms
                    
                } else {
                    results.textContent += '‚ö†Ô∏è Stress test skipped - game engine not accessible\n';
                    testResults.performance.score += 10; // Partial credit
                    testResults.performance.details.push('Stress test skipped');
                    updatePerformanceScore();
                }
                
            } catch (error) {
                results.textContent += `‚ùå Stress test error: ${error.message}\n`;
                testResults.performance.details.push(`Stress test error: ${error.message}`);
                updatePerformanceScore();
            }
        }
        
        function updatePerformanceScore() {
            if (testResults.performance.score >= 75) {
                testResults.performance.status = 'pass';
                document.getElementById('performanceResults').className = 'test-results success';
                updateStatus('performanceStatus', 'pass', `Passed (${testResults.performance.score}/100)`);
            } else if (testResults.performance.score >= 50) {
                testResults.performance.status = 'warning';
                document.getElementById('performanceResults').className = 'test-results warning';
                updateStatus('performanceStatus', 'pending', `Warning (${testResults.performance.score}/100)`);
            } else {
                testResults.performance.status = 'fail';
                document.getElementById('performanceResults').className = 'test-results error';
                updateStatus('performanceStatus', 'fail', `Failed (${testResults.performance.score}/100)`);
            }
            
            document.getElementById('performanceResults').textContent += `\nüìä Performance Test Score: ${testResults.performance.score}/100\n`;
            updateProgress();
            
            // Check if all tests are complete
            checkAllTestsComplete();
        }
        
        // Utility Functions
        function updateStatus(elementId, status, text) {
            const element = document.getElementById(elementId);
            element.className = `status-item ${status}`;
            element.querySelector('p').textContent = text;
        }
        
        function updateProgress() {
            const completedTests = Object.values(testResults).filter(test => test.status !== 'pending').length;
            const totalTests = Object.keys(testResults).length;
            const progress = (completedTests / totalTests) * 100;
            
            document.getElementById('overallProgress').style.width = `${progress}%`;
        }
        
        function checkAllTestsComplete() {
            const allComplete = Object.values(testResults).every(test => test.status !== 'pending');
            
            if (allComplete) {
                generateFinalReport();
            }
        }
        
        function generateFinalReport() {
            const finalResults = document.getElementById('finalResults');
            const finalScore = document.getElementById('finalScore');
            const finalReport = document.getElementById('finalReport');
            
            // Calculate overall score
            const totalScore = Object.values(testResults).reduce((sum, test) => sum + test.score, 0);
            const maxScore = Object.keys(testResults).length * 100;
            const overallPercentage = (totalScore / maxScore) * 100;
            
            // Determine grade and styling
            let grade, className;
            if (overallPercentage >= 85) {
                grade = 'EXCELLENT';
                className = 'score-excellent';
            } else if (overallPercentage >= 70) {
                grade = 'GOOD';
                className = 'score-good';
            } else if (overallPercentage >= 55) {
                grade = 'FAIR';
                className = 'score-fair';
            } else {
                grade = 'NEEDS IMPROVEMENT';
                className = 'score-poor';
            }
            
            finalScore.textContent = `Final Test Results: ${grade} (${overallPercentage.toFixed(1)}%)`;
            finalScore.className = `final-score ${className}`;
            
            // Generate detailed report
            let report = 'üìã COMPREHENSIVE FINAL TEST REPORT\\n';
            report += '=' .repeat(50) + '\\n\\n';
            
            report += `üéØ OVERALL SCORE: ${totalScore}/${maxScore} (${overallPercentage.toFixed(1)}%)\\n`;
            report += `üèÜ GRADE: ${grade}\\n\\n`;
            
            report += 'üìä TEST RESULTS BREAKDOWN:\\n';
            report += '-'.repeat(30) + '\\n';
            
            Object.entries(testResults).forEach(([category, result]) => {
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
                const statusIcon = result.status === 'pass' ? '‚úÖ' : result.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
                report += `${statusIcon} ${categoryName}: ${result.score}/100 (${result.status.toUpperCase()})\\n`;
                
                result.details.forEach(detail => {
                    report += `   ‚Ä¢ ${detail}\\n`;
                });
                report += '\\n';
            });
            
            report += 'üîç DETAILED FINDINGS:\\n';
            report += '-'.repeat(30) + '\\n';
            
            // Success criteria analysis
            const passingTests = Object.values(testResults).filter(test => test.status === 'pass').length;
            const warningTests = Object.values(testResults).filter(test => test.status === 'warning').length;
            const failingTests = Object.values(testResults).filter(test => test.status === 'fail').length;
            
            report += `‚úÖ Passing Tests: ${passingTests}/5\\n`;
            report += `‚ö†Ô∏è Warning Tests: ${warningTests}/5\\n`;
            report += `‚ùå Failing Tests: ${failingTests}/5\\n\\n`;
            
            // Success/Failure criteria check
            report += 'üìã SUCCESS CRITERIA VERIFICATION:\\n';
            report += '-'.repeat(30) + '\\n';
            
            if (testResults.canvas.status === 'pass') {
                report += '‚úÖ Canvas visible with test shapes\\n';
            } else {
                report += '‚ùå Canvas rendering issues detected\\n';
            }
            
            if (testResults.console.status === 'pass') {
                report += '‚úÖ No critical JavaScript console errors\\n';
            } else {
                report += '‚ùå JavaScript errors preventing functionality\\n';
            }
            
            if (testResults.interactive.status === 'pass') {
                report += '‚úÖ All UI controls responsive\\n';
            } else {
                report += '‚ùå UI controls not working properly\\n';
            }
            
            if (testResults.visual.status === 'pass') {
                report += '‚úÖ Visual elements render correctly\\n';
            } else {
                report += '‚ùå Visual rendering issues detected\\n';
            }
            
            if (testResults.performance.status === 'pass') {
                report += '‚úÖ Performance meets requirements\\n';
            } else {
                report += '‚ùå Performance issues or crashes detected\\n';
            }
            
            report += '\\nüìù RECOMMENDATIONS:\\n';
            report += '-'.repeat(30) + '\\n';
            
            if (overallPercentage >= 85) {
                report += 'üéâ Excellent! The golf course map/visualization is working properly.\\n';
                report += 'Ready for production deployment.\\n';
            } else if (overallPercentage >= 70) {
                report += 'üëç Good performance with minor issues.\\n';
                report += 'Address warning items before full deployment.\\n';
            } else if (overallPercentage >= 55) {
                report += '‚ö†Ô∏è Fair performance but needs improvement.\\n';
                report += 'Several issues need to be resolved before deployment.\\n';
            } else {
                report += '‚ùå Poor performance - significant issues detected.\\n';
                report += 'Major fixes required before deployment.\\n';
            }
            
            // Show final results
            finalReport.textContent = report;
            finalReport.className = testResults.console.status === 'fail' || testResults.canvas.status === 'fail' ? 'test-results error' : 
                                   overallPercentage >= 70 ? 'test-results success' : 'test-results warning';
            finalResults.style.display = 'block';
            
            // Scroll to results
            finalResults.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Auto-run all tests when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (confirm('Run comprehensive test suite automatically?')) {
                    runAllTests();
                }
            }, 1000);
        });
        
        async function runAllTests() {
            console.log('üß™ Starting comprehensive test suite...');
            
            // Run tests in sequence with delays
            await runCanvasTest();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await runConsoleTest();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await testClubSelection();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testShotButton();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testCameraControls();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testAccessibility();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testUnitsConversion();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await testVisualElements();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testResponsiveDesign();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testColonistAesthetic();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testAccessibilityFeatures();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await measureLoadingTime();
            await new Promise(resolve => setTimeout(resolve, 2000));
            await testFrameRate();
            await new Promise(resolve => setTimeout(resolve, 2000));
            await checkMemoryUsage();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await runStressTest();
            
            console.log('üß™ Comprehensive test suite completed!');
        }
    </script>
</body>
</html>